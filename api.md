Типы RESTful сервисов:
1. содержит данные, отдает их (погода)
2. особо не содержит данных, но мы можем передать чать данных и сказать, какую операцию выполнить над ними (калькулятор)
3. все в комплексе (интернет-магазин)

Что тестировать, как тестировать, какое покрытие может быть достаточным?

Зная бизнес-требования - можно, используя стандартные сценарии - составить тест-кейсы, разбив приложение на подмодули, для каждого модуля - чеклист или ткейс

Endpoint's.

Протестировать все адреса endpoint'ов (как адреса, относящиеся к коллекциям, так и к единичным ресурсам)
Негативные ТК:
- Обратиться к ресурсу, которого нет (как поведет себя сервер)
- Передать параметры, которых нет (например, для поиска)

- Поиск, фильтрация, сортировка - протестировать каждый из параметров, по отдельности, комбинации параметров. Если параметров много, то pairwise, граничные значения, классы экв-сти и т.д
- Pagination, Cursors. Каждый из параметров и в комбинации. Запросить кол-во товаров больше максимального, обратиться к товарам на странице, которая больше максимального кол-ва страниц
- Версионирование {host}/api/v2


Request Methods.

Узнать для каждого эндпойинта и коллекции какие методы запроса поддерживаются и каждый из них протестировать
Проверить конкурентный доступ (одновременно DELETE and GET)
Негативные:
Для каждой коллекции эндпойнта и одиночного запросить метод, который не поддерживается этим эндпойнтом


Request Headers

Выяснить для каждой коллекции эндпойнта и одиночного какие заголовки поддерживаются.
Протестировать обязательные из них (например, авторизация и content-type)
Граничные значения, классы экв-сти, pairwise, спецсимволы, юникод, максимальную длину и т.д
После обязательных - добавляем необязательный
Негативные:
Не указали обязательный request-header
Передать невалидное значение
Передать заголовок, который не поддерживается сервисом
Пустой заголовок


Request Body (Payload)

Проверить, какие методы доступа поддерживаются для данного эндпойнта и для тех, которые поддерживают Request Body (допустим, POST и PUT) - проверить для этого эндпойнта
Негативные:
Не укажем обязательные поля
Укажем некорректные значения
Укажем значения null
Передадим невалидный json или xml
Передадим пустой объект {}
No data
Для метода DELETE попытаемся удалить объект, которого нет в нашем сервисе


Response Code

Насколько логичны ответы сервера
Нет смысла проверять 500-ые ошибки (их воспроизводит не наш сервис)


Response Headers

Здесь важно понять, какие из них относятся именно к нашему сервису (например, Amazon автоматически добавляет свои headers, если сервис находится на AWS)
Тестировать только заголовки ответа, относящиеся к нашему сервису и то, что клиенты нашего сервиса будут использовать.


Response Body

Проверить структуру ответа
Все ли поля присутствуют
Типы данных полей
Насколько корректные значения


Минимальный позитивный тест для добавления нового юзера:
- Добавить только обязательные request-header's (например, авторизацию и content-type)
- Добавить тело запроса, но только обязательные поля с корректными валидными значениями ({"id": 1, "name": "Ivan", "email": "ivan.ivanov@gmail.com"})
- Отправить запрос (POST request)
- Проверить response code (200 Ok)
- Здесь зависит от реализации. Бывает, что при POST-запросе сразу же возвращается то, что он создал. Бывает, что не возвращает.
Если да: проверяем тело ответа на корректность и проверить заголовки ответа, относящиеся к нашему сервису, а не 3rd party.
Если нет: Проверить через базу данных либо сделать GET запрос, который их нам вернет


- Выяснять какие ограничения на размер значения в поле имени могут быть в прнципе в нашем сервисе (из поля json/xml значение может пойти в объект в программном коде, в БД и т.д)
- Проверять трансформации (json объект может поменяться, firstName, lastName => name)
- State Transition Testing (книга в наличии и не в наличии, одну можем добавить в корзину, другую нет, но и первую и вторую можем добавить в избранное, либо какая то книга уже в корзине и если ее нет в наличии, то она переходит в другое состояние). Какие то переходы разрешены, а какие то не разрешены.
- Caching and Rate Limits (повторный запрос возвращается с кэш-сервера). Проверить, что второй раз быстрее. Лимиты - в минуту кол-во обращений не чаще 10 раз, иначе возвращает 500 код. Проверить максимальное и макс + 1
- Интеграция с 3rd Party (проверить, что наш сервис делает правильный запрос в Facebook)
- Trusted Boundaries


В тестовой стратегии:


REST - это набор правил для построения веб-сервисов
RESTful - это сам сервис, построенный на основе REST


Пример cURL запроса с "красивым" выводом json:
curl -X GET "https://api.openweathermap.org/data/2.5/weather?lat=37.3565982&lon=-121.9689848&units=imperial&appid=<my_number_id>" | python -m json.tool
Или просто в терминале:
echo '{"foo": "lorem", "bar": "ipsum"}' | python -m json.tool
если JSON находится в файле:
python -m json.tool my_json.json
Для удобства можно создать псевдоним:
alias prettyjson='python -m json.tool'

Источник: https://stackoverflow.com/questions/352098/how-can-i-pretty-print-json-in-a-shell-script


cURL
https://starkovden.github.io/understand-curl.html


Подробно:
	curl -v http://www.example.com/
	curl -v http://localhost:8082/spring-rest/foos/9
Очень подробно, для отладки:
	curl --trace-ascii debugdump.txt http://www.example.com/
	curl --trace-ascii d.txt --trace-time http://example.com/
Вывод в файл:
	curl -o out.json http://www.example.com/index.html
Вместе с методом POST:
	curl -d 'id=9&name=baeldung' http://localhost:8082/spring-rest/foos/new
	curl -d @request.json -H "Content-Type: application/json" http://localhost:8082/spring-rest/foos/new
Отключить заголовок User-Agent (указываем пустое значение):
	curl -H "User-Agent:" http://example.com/
	curl -d @request.json -H "Content-Type: application/json" -H "Accept: application/json" http://localhost:8082/spring-rest/foos/new
Для аутентификации Basic используем опцию --user:
	curl --user baeldung:secretPassword http://example.com/
Для OAuth2 аутентификации (сначала получить access_token из службы авторизации):
пример ответа:
{
  "access_token": "b1094abc0-54a4-3eab-7213-877142c33fh3",
  "token_type": "bearer",
  "refresh_token": "253begef-868c-5d48-92e8-448c2ec4bd91",
  "expires_in": 31234
}
Используем полученный токен в заголовке авторизации:
curl -H "Authorization: Bearer b1094abc0-54a4-3eab-7213-877142c33fh3" http://example.com/
